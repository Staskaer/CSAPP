/*
A. andq $-16, X这条指令相当于将低4位置零，
也就是使得rax中保存的8n+30对16取整。所以s2-s1为8n+30对16取整的结果。

B. p的值为rsp(r8)-15对16取整的结果，确保了p数组的起始地址为16的整数倍。

C. 8n + 30对16取整有两种可能：一种是8n本身就是16的整数倍即n = 2k，
此时取整后为8n+16; 另一种是8n = 16k + 8即n = 2k + 1，此时取整后为8n + 24。由System V AMD64 ABI标准可知，s1的地址为16的整数倍(即结尾为0000)，所以s2的地址也肯定是16的整数倍(结尾为0000)。又因p是由s2减15对16取整得到的结果，所以p和s2之间肯定相差2字节，即e2 = 2 bytes. 所以e1最大为（n为奇数） ：8n + 24 - 16 - 8n = 8 bit, 最小为（n为偶数）：8n + 16 -16 - 8n = 0.（这个题我估计没有考虑到ABI标准对于栈帧对齐的问题，s1的地址本来就应该是16的整数倍）

D. 由A B C可知，这种方法保证了s2 和 p的起始地址为16的整数倍，
而且保证了e1最小为8n，能够存储p数组。
*/